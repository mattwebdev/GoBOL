package token

// Token is the type for all COBOL tokens
type Token int

// Position represents a position in the source code
type Position struct {
	Line   int
	Column int
	Offset int
}

// TokenInfo contains information about a token
type TokenInfo struct {
	Type    Token
	Literal string
	Pos     Position
}

const (
	// Special tokens
	ILLEGAL Token = iota
	EOF
	COMMENT
	IDENTIFIER
	STRING
	NUMBER

	// COBOL Divisions
	IDENTIFICATION_DIVISION
	ENVIRONMENT_DIVISION
	DATA_DIVISION
	PROCEDURE_DIVISION

	// COBOL Sections
	CONFIGURATION_SECTION
	INPUT_OUTPUT_SECTION
	FILE_SECTION
	WORKING_STORAGE_SECTION
	LINKAGE_SECTION
	SECTION
	FILE
	LOCAL_STORAGE
	LINKAGE
	PIC
	VALUE
	SOURCE_COMPUTER
	OBJECT_COMPUTER
	TO
	COMP
	EXEC_CICS

	// Keywords
	PROGRAM_ID
	AUTHOR
	INSTALLATION
	DATE_WRITTEN
	DATE_COMPILED
	SECURITY
	ENVIRONMENT
	CONFIGURATION
	SOURCE
	OBJECT
	COMPUTER
	MEMORY
	SEQUENCE
	SEGMENT_LIMIT
	SPECIAL_NAMES
	DECIMAL_POINT
	CONSOLE

	// Basic keywords
	ACCEPT
	ACCESS
	ADD
	ADVANCING
	AFTER
	ALL
	ALPHABETIC

	// Data description
	LEVEL_NUMBER
	REDEFINES
	OCCURS
	TIMES
	DEPENDING
	ON
	INDEXED
	BY_KEYWORD
	ASCENDING
	DESCENDING
	KEY
	IS

	// Figurative constants
	ZERO
	ZEROS
	ZEROES
	SPACE
	SPACES
	HIGH_VALUE
	HIGH_VALUES
	LOW_VALUE
	LOW_VALUES
	QUOTE
	QUOTES
	NULL
	NULLS

	// Special registers
	LENGTH_OF
	ADDRESS_OF
	RETURN_CODE
	WHEN_COMPILED
	TALLY

	// Verbs
	CALL
	COMPUTE
	DISPLAY
	DIVIDE
	MOVE
	MULTIPLY
	PERFORM
	STOP
	SUBTRACT
	INITIALIZE
	SET
	GO
	TO_PROC
	THRU
	VARYING
	FROM
	BY
	UNTIL

	// Conditions and relations
	IF
	ELSE
	END_IF
	EVALUATE
	WHEN
	END_EVALUATE
	GREATER
	LESS
	EQUAL_TO
	GREATER_THAN
	LESS_THAN
	NOT
	AND
	OR
	THAN
	TRUE
	FALSE

	// Literals
	NUMERIC
	STRING_LIT
	CURRENCY

	// Punctuation
	DOT
	COMMA
	SEMICOLON
	LPAREN
	RPAREN
	LBRACE
	RBRACE

	// Operators
	PLUS
	MINUS
	ASTERISK
	SLASH
	EQUAL

	// Identifiers
	IDENT

	// File control tokens
	ASSIGN
	ORGANIZATION
	SEQUENTIAL
	RANDOM
	DYNAMIC

	// Statement end tokens
	END_PERFORM
	END_UNSTRING

	// Exception handling tokens
	TRY
	CATCH
	END_TRY
	FINALLY
	RAISE
	SIZE_ERROR

	// Additional tokens
	DIVISION
	DATA
	PROCEDURE
	FILE_CONTROL
	I_O_CONTROL
	FD
	SELECT
	MODE
	RECORD
	ALTERNATE
	WITH
	DUPLICATES
	FILE_STATUS
	LABEL
	RECORDS
	ARE
	STANDARD
	BLOCK
	CONTAINS
	RECORDING
	RELATIVE
	COMP_1
	COMP_2
	COMP_3
	COMP_4
	COMP_5
	USAGE
	BINARY
	PACKED_DECIMAL
	COMPUTATIONAL
	COMPUTATIONAL_1
	COMPUTATIONAL_2
	COMPUTATIONAL_3
	COMPUTATIONAL_4
	COMPUTATIONAL_5
	POINTER
	SYNC
	SYNCHRONIZED
	LEFT
	RIGHT
	JUSTIFIED
	JUST
	BINARY_CHAR
	BINARY_SHORT
	BINARY_LONG
	BINARY_DOUBLE
	FLOAT_SHORT
	FLOAT_LONG
	FLOAT_EXTENDED
	NATIONAL
	GROUP_USAGE
	NATIONAL_EDITED
	NUMERIC_EDITED
	EXTERNAL
	GLOBAL
	BLANK
	SCREEN
	WHEN_OTHER
	CONTINUE_AFTER
	CONTINUE_SENTENCE
	SORT
	MERGE
	USING
	GIVING
	OUTPUT
	RETURNING
	CALL_CONVENTION
	COMMON
	INITIAL_PROGRAM
	RECURSIVE
	REFERENCE
	CONTENT
	LENGTH
	DELIMITED
	SIZE
	DELIMITER
	COUNT
	INTO
	NO
	ADVANCING_NO_SPACE
	ADVANCING_SPACE
	ADVANCING_TAB
	ADVANCING_PAGE
	ADVANCING_LINE
	ADVANCING_LINES
	END_ACCEPT
	END_ADD
	END_CALL
	END_COMPUTE
	END_DELETE
	END_DISPLAY
	END_DIVIDE
	END_MULTIPLY
	END_READ
	END_RETURN
	END_REWRITE
	END_SEARCH
	END_START
	END_STRING
	END_SUBTRACT
	END_WRITE
	DATA_DIVISION_HEADER
	ENVIRONMENT_DIVISION_HEADER
	IDENTIFICATION_DIVISION_HEADER
	PROCEDURE_DIVISION_HEADER
	OPEN
	CLOSE
	READ
	WRITE
	REWRITE
	DELETE
	START
	RUN
	INPUT
	I_O
	EXTEND
	INVALID_KEY
	NOT_INVALID_KEY
	AT_END
	NOT_AT_END
	COMPILER_DIRECTIVE
	COPY
	REPLACE
	REPLACING
	PSEUDO_TEXT
	PROGRAM
	SUPPRESS
	PRINTING
	EJECT
	SKIP1
	SKIP2
	SKIP3
	CBL
	PROCESS
	EXEC
	SQL
	END_EXEC
	CICS
	DECLARATIVES
	END_DECLARATIVES
	CONTINUE
	NEXT
	SENTENCE
	ENTRY
	EXIT
	GOBACK
	INSPECT
	TALLYING
	FOR
	BEFORE
	INITIAL
	FIRST
	LAST
	LEADING
	TRAILING
	ALSO
	THROUGH
	RENAMES

	// Additional multi-word tokens
	PICTURE_CLAUSE Token = iota + 500
	WORKING_STORAGE
	DATA_RECORD
	RECORD_CONTAINS
	BLOCK_CONTAINS
	RECORDING_MODE
	LABEL_RECORDS
	VALUE_OF
	DATA_RECORDS
	LINAGE_IS
	CODE_SET
	REPORT_IS
	REPORTS_ARE
	CONTROL_IS
	CONTROLS_ARE
	PAGE_LIMIT
	HEADING_IS
	FIRST_DETAIL
	LAST_DETAIL
	FOOTING_IS
)

// String constants for multi-word tokens
const (
	PICTURE_CLAUSE_STR  = "PICTURE"
	WORKING_STORAGE_STR = "WORKING-STORAGE"
	DATA_RECORD_STR     = "DATA RECORD"
	RECORD_CONTAINS_STR = "RECORD CONTAINS"
	BLOCK_CONTAINS_STR  = "BLOCK CONTAINS"
	RECORDING_MODE_STR  = "RECORDING MODE"
	LABEL_RECORDS_STR   = "LABEL RECORDS"
	VALUE_OF_STR        = "VALUE OF"
	DATA_RECORDS_STR    = "DATA RECORDS"
	LINAGE_IS_STR       = "LINAGE IS"
	CODE_SET_STR        = "CODE-SET"
	REPORT_IS_STR       = "REPORT IS"
	REPORTS_ARE_STR     = "REPORTS ARE"
	CONTROL_IS_STR      = "CONTROL IS"
	CONTROLS_ARE_STR    = "CONTROLS ARE"
	PAGE_LIMIT_STR      = "PAGE LIMIT"
	HEADING_IS_STR      = "HEADING IS"
	FIRST_DETAIL_STR    = "FIRST DETAIL"
	LAST_DETAIL_STR     = "LAST DETAIL"
	FOOTING_IS_STR      = "FOOTING IS"
)

// Basic string constants
const (
	// Divisions
	IDENTIFICATION_DIV_STR = "IDENTIFICATION DIVISION"
	ENVIRONMENT_DIV_STR    = "ENVIRONMENT DIVISION"
	DATA_DIV_STR           = "DATA DIVISION"
	PROCEDURE_DIV_STR      = "PROCEDURE DIVISION"

	// Sections
	CONFIGURATION_SECT_STR   = "CONFIGURATION SECTION"
	INPUT_OUTPUT_SECT_STR    = "INPUT-OUTPUT SECTION"
	FILE_SECT_STR            = "FILE SECTION"
	WORKING_STORAGE_SECT_STR = "WORKING-STORAGE SECTION"
	LINKAGE_SECT_STR         = "LINKAGE SECTION"

	// Individual keywords
	PROGRAM_ID_STR    = "PROGRAM-ID"
	AUTHOR_STR        = "AUTHOR"
	INSTALLATION_STR  = "INSTALLATION"
	DATE_WRITTEN_STR  = "DATE-WRITTEN"
	DATE_COMPILED_STR = "DATE-COMPILED"
	SECURITY_STR      = "SECURITY"
	ENVIRONMENT_STR   = "ENVIRONMENT"
	CONFIGURATION_STR = "CONFIGURATION"
	SOURCE_STR        = "SOURCE"
	OBJECT_STR        = "OBJECT"
	COMPUTER_STR      = "COMPUTER"
	MEMORY_STR        = "MEMORY"
	SEQUENCE_STR      = "SEQUENCE"
	SEGMENT_LIMIT_STR = "SEGMENT-LIMIT"
	SPECIAL_NAMES_STR = "SPECIAL-NAMES"
	DECIMAL_POINT_STR = "DECIMAL-POINT"
	CONSOLE_STR       = "CONSOLE"
)

// Data description string constants
const (
	REDEFINES_STR  = "REDEFINES"
	OCCURS_STR     = "OCCURS"
	TIMES_STR      = "TIMES"
	DEPENDING_STR  = "DEPENDING"
	ON_STR         = "ON"
	INDEXED_STR    = "INDEXED"
	BY_KEYWORD_STR = "BY"
	ASCENDING_STR  = "ASCENDING"
	DESCENDING_STR = "DESCENDING"
	KEY_STR        = "KEY"
	IS_STR         = "IS"
)

// Figurative constants string constants
const (
	ZERO_STR        = "ZERO"
	ZEROS_STR       = "ZEROS"
	ZEROES_STR      = "ZEROES"
	SPACE_STR       = "SPACE"
	SPACES_STR      = "SPACES"
	HIGH_VALUE_STR  = "HIGH-VALUE"
	HIGH_VALUES_STR = "HIGH-VALUES"
	LOW_VALUE_STR   = "LOW-VALUE"
	LOW_VALUES_STR  = "LOW-VALUES"
	QUOTE_STR       = "QUOTE"
	QUOTES_STR      = "QUOTES"
	NULL_STR        = "NULL"
	NULLS_STR       = "NULLS"
)

// Special registers string constants
const (
	LENGTH_OF_STR     = "LENGTH OF"
	ADDRESS_OF_STR    = "ADDRESS OF"
	RETURN_CODE_STR   = "RETURN-CODE"
	WHEN_COMPILED_STR = "WHEN-COMPILED"
	TALLY_STR         = "TALLY"
)

// File handling string constants
const (
	ASSIGN_STR       = "ASSIGN"
	ORGANIZATION_STR = "ORGANIZATION"
	SEQUENTIAL_STR   = "SEQUENTIAL"
	RANDOM_STR       = "RANDOM"
	DYNAMIC_STR      = "DYNAMIC"
)

// Control flow string constants
const (
	END_PERFORM_STR = "END-PERFORM"
	TRY_STR         = "TRY"
	CATCH_STR       = "CATCH"
	END_TRY_STR     = "END-TRY"
	FINALLY_STR     = "FINALLY"
	RAISE_STR       = "RAISE"
	SIZE_ERROR_STR  = "SIZE ERROR"
)

// Basic keyword string constants
const (
	DIVISION_STR  = "DIVISION"
	PROGRAM_STR   = "PROGRAM"
	COPY_STR      = "COPY"
	REPLACE_STR   = "REPLACE"
	REPLACING_STR = "REPLACING"
	SUPPRESS_STR  = "SUPPRESS"
	PRINTING_STR  = "PRINTING"
	EJECT_STR     = "EJECT"
	SKIP1_STR     = "SKIP1"
	SKIP2_STR     = "SKIP2"
	SKIP3_STR     = "SKIP3"
	CBL_STR       = "CBL"
	PROCESS_STR   = "PROCESS"
	EXEC_STR      = "EXEC"
	SQL_STR       = "SQL"
	END_EXEC_STR  = "END-EXEC"
	CICS_STR      = "CICS"
)

// Procedure division string constants
const (
	DECLARATIVES_STR     = "DECLARATIVES"
	END_DECLARATIVES_STR = "END DECLARATIVES"
	CONTINUE_STR         = "CONTINUE"
	NEXT_STR             = "NEXT"
	SENTENCE_STR         = "SENTENCE"
	ENTRY_STR            = "ENTRY"
	EXIT_STR             = "EXIT"
	GOBACK_STR           = "GOBACK"
	INSPECT_STR          = "INSPECT"
	TALLYING_STR         = "TALLYING"
	FOR_STR              = "FOR"
	BEFORE_STR           = "BEFORE"
	INITIAL_STR          = "INITIAL"
	FIRST_STR            = "FIRST"
	LAST_STR             = "LAST"
	LEADING_STR          = "LEADING"
	TRAILING_STR         = "TRAILING"
	ALSO_STR             = "ALSO"
	THROUGH_STR          = "THROUGH"
	RENAMES_STR          = "RENAMES"
)

// Data description string constants
const (
	BINARY_STR          = "BINARY"
	PACKED_DECIMAL_STR  = "PACKED-DECIMAL"
	COMP_1_STR          = "COMP-1"
	COMP_2_STR          = "COMP-2"
	COMP_3_STR          = "COMP-3"
	COMP_4_STR          = "COMP-4"
	COMP_5_STR          = "COMP-5"
	USAGE_STR           = "USAGE"
	COMPUTATIONAL_STR   = "COMPUTATIONAL"
	COMPUTATIONAL_1_STR = "COMPUTATIONAL-1"
	COMPUTATIONAL_2_STR = "COMPUTATIONAL-2"
	COMPUTATIONAL_3_STR = "COMPUTATIONAL-3"
	COMPUTATIONAL_4_STR = "COMPUTATIONAL-4"
	COMPUTATIONAL_5_STR = "COMPUTATIONAL-5"
	POINTER_STR         = "POINTER"
	SYNC_STR            = "SYNC"
	SYNCHRONIZED_STR    = "SYNCHRONIZED"
	LEFT_STR            = "LEFT"
	RIGHT_STR           = "RIGHT"
	JUSTIFIED_STR       = "JUSTIFIED"
	JUST_STR            = "JUST"
	BINARY_CHAR_STR     = "BINARY-CHAR"
	BINARY_SHORT_STR    = "BINARY-SHORT"
	BINARY_LONG_STR     = "BINARY-LONG"
	BINARY_DOUBLE_STR   = "BINARY-DOUBLE"
	FLOAT_SHORT_STR     = "FLOAT-SHORT"
	FLOAT_LONG_STR      = "FLOAT-LONG"
	FLOAT_EXTENDED_STR  = "FLOAT-EXTENDED"
	NATIONAL_STR        = "NATIONAL"
	GROUP_USAGE_STR     = "GROUP-USAGE"
	NATIONAL_EDITED_STR = "NATIONAL-EDITED"
	NUMERIC_EDITED_STR  = "NUMERIC-EDITED"
	EXTERNAL_STR        = "EXTERNAL"
	GLOBAL_STR          = "GLOBAL"
	BLANK_STR           = "BLANK"
	SCREEN_STR          = "SCREEN"
)

// Additional keyword string constants
const (
	WHEN_OTHER_STR        = "WHEN OTHER"
	CONTINUE_AFTER_STR    = "CONTINUE AFTER"
	CONTINUE_SENTENCE_STR = "CONTINUE SENTENCE"
	SORT_STR              = "SORT"
	MERGE_STR             = "MERGE"
	USING_STR             = "USING"
	GIVING_STR            = "GIVING"
	OUTPUT_STR            = "OUTPUT"
	RETURNING_STR         = "RETURNING"
	CALL_CONVENTION_STR   = "CALL-CONVENTION"
	COMMON_STR            = "COMMON"
	INITIAL_PROGRAM_STR   = "INITIAL PROGRAM"
	RECURSIVE_STR         = "RECURSIVE"
	REFERENCE_STR         = "REFERENCE"
	CONTENT_STR           = "CONTENT"
	LENGTH_STR            = "LENGTH"
	DELIMITED_STR         = "DELIMITED"
	SIZE_STR              = "SIZE"
	DELIMITER_STR         = "DELIMITER"
	COUNT_STR             = "COUNT"
	INTO_STR              = "INTO"
	WITH_STR              = "WITH"
	NO_STR                = "NO"
)

// Statement termination string constants
const (
	END_ACCEPT_STR   = "END-ACCEPT"
	END_ADD_STR      = "END-ADD"
	END_CALL_STR     = "END-CALL"
	END_COMPUTE_STR  = "END-COMPUTE"
	END_DELETE_STR   = "END-DELETE"
	END_DISPLAY_STR  = "END-DISPLAY"
	END_DIVIDE_STR   = "END-DIVIDE"
	END_MULTIPLY_STR = "END-MULTIPLY"
	END_READ_STR     = "END-READ"
	END_RETURN_STR   = "END-RETURN"
	END_REWRITE_STR  = "END-REWRITE"
	END_SEARCH_STR   = "END-SEARCH"
	END_START_STR    = "END-START"
	END_STRING_STR   = "END-STRING"
	END_SUBTRACT_STR = "END-SUBTRACT"
	END_UNSTRING_STR = "END-UNSTRING"
	END_WRITE_STR    = "END-WRITE"
)

// Division header string constants
const (
	DATA_DIVISION_HEADER_STR           = "DATA DIVISION"
	ENVIRONMENT_DIVISION_HEADER_STR    = "ENVIRONMENT DIVISION"
	IDENTIFICATION_DIVISION_HEADER_STR = "IDENTIFICATION DIVISION"
	PROCEDURE_DIVISION_HEADER_STR      = "PROCEDURE DIVISION"
)

// I/O handling string constants
const (
	INVALID_KEY_STR     = "INVALID KEY"
	NOT_INVALID_KEY_STR = "NOT INVALID KEY"
	AT_END_STR          = "AT END"
	NOT_AT_END_STR      = "NOT AT END"
	FILE_STATUS_STR     = "FILE STATUS"
)

// Advancing string constants
const (
	ADVANCING_NO_SPACE_STR = "ADVANCING NO SPACE"
	ADVANCING_SPACE_STR    = "ADVANCING SPACE"
	ADVANCING_TAB_STR      = "ADVANCING TAB"
	ADVANCING_PAGE_STR     = "ADVANCING PAGE"
	ADVANCING_LINE_STR     = "ADVANCING LINE"
	ADVANCING_LINES_STR    = "ADVANCING LINES"
)

// Special register token string constants
const (
	LENGTH_OF_TOKEN_STR   = "LENGTH OF"
	ADDRESS_OF_TOKEN_STR  = "ADDRESS OF"
	HIGH_VALUE_TOKEN_STR  = "HIGH-VALUE"
	HIGH_VALUES_TOKEN_STR = "HIGH-VALUES"
	LOW_VALUE_TOKEN_STR   = "LOW-VALUE"
	LOW_VALUES_TOKEN_STR  = "LOW-VALUES"
)

var keywords = map[string]Token{
	// Divisions
	IDENTIFICATION_DIV_STR: IDENTIFICATION_DIVISION,
	ENVIRONMENT_DIV_STR:    ENVIRONMENT_DIVISION,
	DATA_DIV_STR:           DATA_DIVISION,
	PROCEDURE_DIV_STR:      PROCEDURE_DIVISION,

	// Sections
	CONFIGURATION_SECT_STR:   CONFIGURATION_SECTION,
	INPUT_OUTPUT_SECT_STR:    INPUT_OUTPUT_SECTION,
	FILE_SECT_STR:            FILE_SECTION,
	WORKING_STORAGE_SECT_STR: WORKING_STORAGE_SECTION,
	LINKAGE_SECT_STR:         LINKAGE_SECTION,

	// Basic keywords
	PROGRAM_ID_STR:    PROGRAM_ID,
	AUTHOR_STR:        AUTHOR,
	INSTALLATION_STR:  INSTALLATION,
	DATE_WRITTEN_STR:  DATE_WRITTEN,
	DATE_COMPILED_STR: DATE_COMPILED,
	SECURITY_STR:      SECURITY,
	ENVIRONMENT_STR:   ENVIRONMENT,
	CONFIGURATION_STR: CONFIGURATION,
	SOURCE_STR:        SOURCE,
	OBJECT_STR:        OBJECT,
	COMPUTER_STR:      COMPUTER,
	MEMORY_STR:        MEMORY,
	SEQUENCE_STR:      SEQUENCE,
	SEGMENT_LIMIT_STR: SEGMENT_LIMIT,
	SPECIAL_NAMES_STR: SPECIAL_NAMES,
	DECIMAL_POINT_STR: DECIMAL_POINT,
	CONSOLE_STR:       CONSOLE,

	// Data description
	REDEFINES_STR:  REDEFINES,
	OCCURS_STR:     OCCURS,
	TIMES_STR:      TIMES,
	DEPENDING_STR:  DEPENDING,
	ON_STR:         ON,
	INDEXED_STR:    INDEXED,
	BY_KEYWORD_STR: BY_KEYWORD,
	ASCENDING_STR:  ASCENDING,
	DESCENDING_STR: DESCENDING,
	KEY_STR:        KEY,
	IS_STR:         IS,

	// Figurative constants
	ZERO_STR:        ZERO,
	ZEROS_STR:       ZEROS,
	ZEROES_STR:      ZEROES,
	SPACE_STR:       SPACE,
	SPACES_STR:      SPACES,
	HIGH_VALUE_STR:  HIGH_VALUE,
	HIGH_VALUES_STR: HIGH_VALUES,
	LOW_VALUE_STR:   LOW_VALUE,
	LOW_VALUES_STR:  LOW_VALUES,
	QUOTE_STR:       QUOTE,
	QUOTES_STR:      QUOTES,
	NULL_STR:        NULL,
	NULLS_STR:       NULLS,

	// Special registers
	LENGTH_OF_STR:     LENGTH_OF,
	ADDRESS_OF_STR:    ADDRESS_OF,
	RETURN_CODE_STR:   RETURN_CODE,
	WHEN_COMPILED_STR: WHEN_COMPILED,
	TALLY_STR:         TALLY,

	// File handling
	ASSIGN_STR:       ASSIGN,
	ORGANIZATION_STR: ORGANIZATION,
	SEQUENTIAL_STR:   SEQUENTIAL,
	RANDOM_STR:       RANDOM,
	DYNAMIC_STR:      DYNAMIC,

	// Control flow
	END_PERFORM_STR: END_PERFORM,
	TRY_STR:         TRY,
	CATCH_STR:       CATCH,
	END_TRY_STR:     END_TRY,
	FINALLY_STR:     FINALLY,
	RAISE_STR:       RAISE,
	SIZE_ERROR_STR:  SIZE_ERROR,

	// Basic keywords
	DIVISION_STR:  DIVISION,
	PROGRAM_STR:   PROGRAM,
	COPY_STR:      COPY,
	REPLACE_STR:   REPLACE,
	REPLACING_STR: REPLACING,
	SUPPRESS_STR:  SUPPRESS,
	PRINTING_STR:  PRINTING,
	EJECT_STR:     EJECT,
	SKIP1_STR:     SKIP1,
	SKIP2_STR:     SKIP2,
	SKIP3_STR:     SKIP3,
	CBL_STR:       CBL,
	PROCESS_STR:   PROCESS,
	EXEC_STR:      EXEC,
	SQL_STR:       SQL,
	END_EXEC_STR:  END_EXEC,
	CICS_STR:      CICS,

	// Procedure division
	DECLARATIVES_STR:     DECLARATIVES,
	END_DECLARATIVES_STR: END_DECLARATIVES,
	CONTINUE_STR:         CONTINUE,
	NEXT_STR:             NEXT,
	SENTENCE_STR:         SENTENCE,
	ENTRY_STR:            ENTRY,
	EXIT_STR:             EXIT,
	GOBACK_STR:           GOBACK,
	INSPECT_STR:          INSPECT,
	TALLYING_STR:         TALLYING,
	FOR_STR:              FOR,
	BEFORE_STR:           BEFORE,
	INITIAL_STR:          INITIAL,
	FIRST_STR:            FIRST,
	LAST_STR:             LAST,
	LEADING_STR:          LEADING,
	TRAILING_STR:         TRAILING,
	ALSO_STR:             ALSO,
	THROUGH_STR:          THROUGH,
	RENAMES_STR:          RENAMES,

	// Data description
	BINARY_STR:          BINARY,
	PACKED_DECIMAL_STR:  PACKED_DECIMAL,
	COMP_1_STR:          COMP_1,
	COMP_2_STR:          COMP_2,
	COMP_3_STR:          COMP_3,
	COMP_4_STR:          COMP_4,
	COMP_5_STR:          COMP_5,
	USAGE_STR:           USAGE,
	COMPUTATIONAL_STR:   COMPUTATIONAL,
	COMPUTATIONAL_1_STR: COMPUTATIONAL_1,
	COMPUTATIONAL_2_STR: COMPUTATIONAL_2,
	COMPUTATIONAL_3_STR: COMPUTATIONAL_3,
	COMPUTATIONAL_4_STR: COMPUTATIONAL_4,
	COMPUTATIONAL_5_STR: COMPUTATIONAL_5,
	POINTER_STR:         POINTER,
	SYNC_STR:            SYNC,
	SYNCHRONIZED_STR:    SYNCHRONIZED,
	LEFT_STR:            LEFT,
	RIGHT_STR:           RIGHT,
	JUSTIFIED_STR:       JUSTIFIED,
	JUST_STR:            JUST,
	BINARY_CHAR_STR:     BINARY_CHAR,
	BINARY_SHORT_STR:    BINARY_SHORT,
	BINARY_LONG_STR:     BINARY_LONG,
	BINARY_DOUBLE_STR:   BINARY_DOUBLE,
	FLOAT_SHORT_STR:     FLOAT_SHORT,
	FLOAT_LONG_STR:      FLOAT_LONG,
	FLOAT_EXTENDED_STR:  FLOAT_EXTENDED,
	NATIONAL_STR:        NATIONAL,
	GROUP_USAGE_STR:     GROUP_USAGE,
	NATIONAL_EDITED_STR: NATIONAL_EDITED,
	NUMERIC_EDITED_STR:  NUMERIC_EDITED,
	EXTERNAL_STR:        EXTERNAL,
	GLOBAL_STR:          GLOBAL,
	BLANK_STR:           BLANK,
	SCREEN_STR:          SCREEN,

	// Additional keywords
	WHEN_OTHER_STR:        WHEN_OTHER,
	CONTINUE_AFTER_STR:    CONTINUE_AFTER,
	CONTINUE_SENTENCE_STR: CONTINUE_SENTENCE,
	SORT_STR:              SORT,
	MERGE_STR:             MERGE,
	USING_STR:             USING,
	GIVING_STR:            GIVING,
	OUTPUT_STR:            OUTPUT,
	RETURNING_STR:         RETURNING,
	CALL_CONVENTION_STR:   CALL_CONVENTION,
	COMMON_STR:            COMMON,
	INITIAL_PROGRAM_STR:   INITIAL_PROGRAM,
	RECURSIVE_STR:         RECURSIVE,
	REFERENCE_STR:         REFERENCE,
	CONTENT_STR:           CONTENT,
	LENGTH_STR:            LENGTH,
	DELIMITED_STR:         DELIMITED,
	SIZE_STR:              SIZE,
	DELIMITER_STR:         DELIMITER,
	COUNT_STR:             COUNT,
	INTO_STR:              INTO,
	WITH_STR:              WITH,
	NO_STR:                NO,

	// Statement termination
	END_ACCEPT_STR:   END_ACCEPT,
	END_ADD_STR:      END_ADD,
	END_CALL_STR:     END_CALL,
	END_COMPUTE_STR:  END_COMPUTE,
	END_DELETE_STR:   END_DELETE,
	END_DISPLAY_STR:  END_DISPLAY,
	END_DIVIDE_STR:   END_DIVIDE,
	END_MULTIPLY_STR: END_MULTIPLY,
	END_READ_STR:     END_READ,
	END_RETURN_STR:   END_RETURN,
	END_REWRITE_STR:  END_REWRITE,
	END_SEARCH_STR:   END_SEARCH,
	END_START_STR:    END_START,
	END_STRING_STR:   END_STRING,
	END_SUBTRACT_STR: END_SUBTRACT,
	END_UNSTRING_STR: END_UNSTRING,
	END_WRITE_STR:    END_WRITE,

	// I/O handling
	INVALID_KEY_STR:     INVALID_KEY,
	NOT_INVALID_KEY_STR: NOT_INVALID_KEY,
	AT_END_STR:          AT_END,
	NOT_AT_END_STR:      NOT_AT_END,
	FILE_STATUS_STR:     FILE_STATUS,

	// Advancing
	ADVANCING_NO_SPACE_STR: ADVANCING_NO_SPACE,
	ADVANCING_SPACE_STR:    ADVANCING_SPACE,
	ADVANCING_TAB_STR:      ADVANCING_TAB,
	ADVANCING_PAGE_STR:     ADVANCING_PAGE,
	ADVANCING_LINE_STR:     ADVANCING_LINE,
	ADVANCING_LINES_STR:    ADVANCING_LINES,

	// Multi-word tokens
	PICTURE_CLAUSE_STR:  PICTURE_CLAUSE,
	WORKING_STORAGE_STR: WORKING_STORAGE,
	DATA_RECORD_STR:     DATA_RECORD,
	RECORD_CONTAINS_STR: RECORD_CONTAINS,
	BLOCK_CONTAINS_STR:  BLOCK_CONTAINS,
	RECORDING_MODE_STR:  RECORDING_MODE,
	LABEL_RECORDS_STR:   LABEL_RECORDS,
	VALUE_OF_STR:        VALUE_OF,
	DATA_RECORDS_STR:    DATA_RECORDS,
	LINAGE_IS_STR:       LINAGE_IS,
	CODE_SET_STR:        CODE_SET,
	REPORT_IS_STR:       REPORT_IS,
	REPORTS_ARE_STR:     REPORTS_ARE,
	CONTROL_IS_STR:      CONTROL_IS,
	CONTROLS_ARE_STR:    CONTROLS_ARE,
	PAGE_LIMIT_STR:      PAGE_LIMIT,
	HEADING_IS_STR:      HEADING_IS,
	FIRST_DETAIL_STR:    FIRST_DETAIL,
	LAST_DETAIL_STR:     LAST_DETAIL,
	FOOTING_IS_STR:      FOOTING_IS,
}

// String returns the string representation of the token
func (t Token) String() string {
	switch t {
	case ILLEGAL:
		return "ILLEGAL"
	case EOF:
		return "EOF"
	case COMMENT:
		return "COMMENT"
	case IDENTIFICATION_DIVISION:
		return IDENTIFICATION_DIV_STR
	case ENVIRONMENT_DIVISION:
		return ENVIRONMENT_DIV_STR
	case DATA_DIVISION:
		return DATA_DIV_STR
	case PROCEDURE_DIVISION:
		return PROCEDURE_DIV_STR
	case CONFIGURATION_SECTION:
		return CONFIGURATION_SECT_STR
	case INPUT_OUTPUT_SECTION:
		return INPUT_OUTPUT_SECT_STR
	case FILE_SECTION:
		return FILE_SECT_STR
	case WORKING_STORAGE_SECTION:
		return WORKING_STORAGE_SECT_STR
	case LINKAGE_SECTION:
		return LINKAGE_SECT_STR
	case PROGRAM_ID:
		return PROGRAM_ID_STR
	case AUTHOR:
		return AUTHOR_STR
	case INSTALLATION:
		return INSTALLATION_STR
	case DATE_WRITTEN:
		return DATE_WRITTEN_STR
	case DATE_COMPILED:
		return DATE_COMPILED_STR
	case SECURITY:
		return SECURITY_STR
	case ENVIRONMENT:
		return ENVIRONMENT_STR
	case CONFIGURATION:
		return CONFIGURATION_STR
	case SOURCE:
		return SOURCE_STR
	case OBJECT:
		return OBJECT_STR
	case COMPUTER:
		return COMPUTER_STR
	case MEMORY:
		return MEMORY_STR
	case SEQUENCE:
		return SEQUENCE_STR
	case SEGMENT_LIMIT:
		return SEGMENT_LIMIT_STR
	case SPECIAL_NAMES:
		return SPECIAL_NAMES_STR
	case DECIMAL_POINT:
		return DECIMAL_POINT_STR
	case CONSOLE:
		return CONSOLE_STR
	case ACCEPT:
		return "ACCEPT"
	case ACCESS:
		return "ACCESS"
	case ADD:
		return "ADD"
	case ADVANCING:
		return "ADVANCING"
	case AFTER:
		return "AFTER"
	case ALL:
		return "ALL"
	case ALPHABETIC:
		return "ALPHABETIC"
	case DIVISION:
		return "DIVISION"
	case DATA:
		return "DATA"
	case PROCEDURE:
		return "PROCEDURE"
	case SOURCE_COMPUTER:
		return "SOURCE-COMPUTER"
	case OBJECT_COMPUTER:
		return "OBJECT-COMPUTER"
	case FILE_CONTROL:
		return "FILE-CONTROL"
	case I_O_CONTROL:
		return "I-O-CONTROL"
	case FD:
		return "FD"
	case SELECT:
		return "SELECT"
	case MODE:
		return "MODE"
	case RECORD:
		return "RECORD"
	case ALTERNATE:
		return "ALTERNATE"
	case WITH:
		return "WITH"
	case DUPLICATES:
		return "DUPLICATES"
	case FILE_STATUS:
		return "FILE STATUS"
	case LABEL:
		return "LABEL"
	case RECORDS:
		return "RECORDS"
	case ARE:
		return "ARE"
	case STANDARD:
		return "STANDARD"
	case BLOCK:
		return "BLOCK"
	case CONTAINS:
		return "CONTAINS"
	case RECORDING:
		return "RECORDING"
	case RELATIVE:
		return "RELATIVE"
	case COMP_1:
		return "COMP-1"
	case COMP_2:
		return "COMP-2"
	case COMP_3:
		return "COMP-3"
	case COMP_4:
		return "COMP-4"
	case COMP_5:
		return "COMP-5"
	case USAGE:
		return "USAGE"
	case BINARY:
		return "BINARY"
	case PACKED_DECIMAL:
		return "PACKED-DECIMAL"
	case COMPUTATIONAL:
		return "COMPUTATIONAL"
	case COMPUTATIONAL_1:
		return "COMPUTATIONAL-1"
	case COMPUTATIONAL_2:
		return "COMPUTATIONAL-2"
	case COMPUTATIONAL_3:
		return "COMPUTATIONAL-3"
	case COMPUTATIONAL_4:
		return "COMPUTATIONAL-4"
	case COMPUTATIONAL_5:
		return "COMPUTATIONAL-5"
	case POINTER:
		return "POINTER"
	case SYNC:
		return "SYNC"
	case SYNCHRONIZED:
		return "SYNCHRONIZED"
	case LEFT:
		return "LEFT"
	case RIGHT:
		return "RIGHT"
	case JUSTIFIED:
		return "JUSTIFIED"
	case JUST:
		return "JUST"
	case BINARY_CHAR:
		return "BINARY-CHAR"
	case BINARY_SHORT:
		return "BINARY-SHORT"
	case BINARY_LONG:
		return "BINARY-LONG"
	case BINARY_DOUBLE:
		return "BINARY-DOUBLE"
	case FLOAT_SHORT:
		return "FLOAT-SHORT"
	case FLOAT_LONG:
		return "FLOAT-LONG"
	case FLOAT_EXTENDED:
		return "FLOAT-EXTENDED"
	case NATIONAL:
		return "NATIONAL"
	case GROUP_USAGE:
		return "GROUP-USAGE"
	case NATIONAL_EDITED:
		return "NATIONAL-EDITED"
	case NUMERIC_EDITED:
		return "NUMERIC-EDITED"
	case EXTERNAL:
		return "EXTERNAL"
	case GLOBAL:
		return "GLOBAL"
	case BLANK:
		return "BLANK"
	case SCREEN:
		return "SCREEN"
	case WHEN_OTHER:
		return "WHEN OTHER"
	case CONTINUE_AFTER:
		return "CONTINUE AFTER"
	case CONTINUE_SENTENCE:
		return "CONTINUE SENTENCE"
	case SORT:
		return "SORT"
	case MERGE:
		return "MERGE"
	case USING:
		return "USING"
	case GIVING:
		return "GIVING"
	case OUTPUT:
		return "OUTPUT"
	case RETURNING:
		return "RETURNING"
	case CALL_CONVENTION:
		return "CALL-CONVENTION"
	case COMMON:
		return "COMMON"
	case INITIAL_PROGRAM:
		return "INITIAL"
	case RECURSIVE:
		return "RECURSIVE"
	case REFERENCE:
		return "REFERENCE"
	case CONTENT:
		return "CONTENT"
	case LENGTH:
		return "LENGTH"
	case DELIMITED:
		return "DELIMITED"
	case SIZE:
		return "SIZE"
	case DELIMITER:
		return "DELIMITER"
	case COUNT:
		return "COUNT"
	case INTO:
		return "INTO"
	case NO:
		return "NO"
	case ADVANCING_NO_SPACE:
		return "ADVANCING NO SPACE"
	case ADVANCING_SPACE:
		return "ADVANCING SPACE"
	case ADVANCING_TAB:
		return "ADVANCING TAB"
	case ADVANCING_PAGE:
		return "ADVANCING PAGE"
	case ADVANCING_LINE:
		return "ADVANCING LINE"
	case ADVANCING_LINES:
		return "ADVANCING LINES"
	case END_ACCEPT:
		return "END-ACCEPT"
	case END_ADD:
		return "END-ADD"
	case END_CALL:
		return "END-CALL"
	case END_COMPUTE:
		return "END-COMPUTE"
	case END_DELETE:
		return "END-DELETE"
	case END_DISPLAY:
		return "END-DISPLAY"
	case END_DIVIDE:
		return "END-DIVIDE"
	case END_MULTIPLY:
		return "END-MULTIPLY"
	case END_READ:
		return "END-READ"
	case END_RETURN:
		return "END-RETURN"
	case END_REWRITE:
		return "END-REWRITE"
	case END_SEARCH:
		return "END-SEARCH"
	case END_START:
		return "END-START"
	case END_STRING:
		return "END-STRING"
	case END_SUBTRACT:
		return "END-SUBTRACT"
	case END_UNSTRING:
		return "END-UNSTRING"
	case END_WRITE:
		return "END-WRITE"
	case DATA_DIVISION_HEADER:
		return "DATA DIVISION"
	case ENVIRONMENT_DIVISION_HEADER:
		return "ENVIRONMENT DIVISION"
	case IDENTIFICATION_DIVISION_HEADER:
		return "IDENTIFICATION DIVISION"
	case PROCEDURE_DIVISION_HEADER:
		return "PROCEDURE DIVISION"
	case OPEN:
		return "OPEN"
	case CLOSE:
		return "CLOSE"
	case READ:
		return "READ"
	case WRITE:
		return "WRITE"
	case REWRITE:
		return "REWRITE"
	case DELETE:
		return "DELETE"
	case START:
		return "START"
	case RUN:
		return "RUN"
	case INPUT:
		return "INPUT"
	case I_O:
		return "I-O"
	case EXTEND:
		return "EXTEND"
	case INVALID_KEY:
		return "INVALID KEY"
	case NOT_INVALID_KEY:
		return "NOT INVALID KEY"
	case AT_END:
		return "AT END"
	case NOT_AT_END:
		return "NOT AT END"
	case COMPILER_DIRECTIVE:
		return ">>"
	case COPY:
		return "COPY"
	case REPLACE:
		return "REPLACE"
	case REPLACING:
		return "REPLACING"
	case PSEUDO_TEXT:
		return "=="
	case PROGRAM:
		return "PROGRAM"
	case SUPPRESS:
		return "SUPPRESS"
	case PRINTING:
		return "PRINTING"
	case EJECT:
		return "EJECT"
	case SKIP1:
		return "SKIP1"
	case SKIP2:
		return "SKIP2"
	case SKIP3:
		return "SKIP3"
	case CBL:
		return "CBL"
	case PROCESS:
		return "PROCESS"
	case EXEC:
		return "EXEC"
	case SQL:
		return "SQL"
	case END_EXEC:
		return "END-EXEC"
	case CICS:
		return "CICS"
	case DECLARATIVES:
		return "DECLARATIVES"
	case END_DECLARATIVES:
		return "END DECLARATIVES"
	case CONTINUE:
		return "CONTINUE"
	case NEXT:
		return "NEXT"
	case SENTENCE:
		return "SENTENCE"
	case ENTRY:
		return "ENTRY"
	case EXIT:
		return "EXIT"
	case GOBACK:
		return "GOBACK"
	case INSPECT:
		return "INSPECT"
	case TALLYING:
		return "TALLYING"
	case FOR:
		return "FOR"
	case BEFORE:
		return "BEFORE"
	case INITIAL:
		return "INITIAL"
	case FIRST:
		return "FIRST"
	case LAST:
		return "LAST"
	case LEADING:
		return "LEADING"
	case TRAILING:
		return "TRAILING"
	case ALSO:
		return "ALSO"
	case THROUGH:
		return "THROUGH"
	case RENAMES:
		return "RENAMES"
	case PICTURE_CLAUSE:
		return "PICTURE"
	case WORKING_STORAGE:
		return "WORKING-STORAGE"
	case DATA_RECORD:
		return "DATA RECORD"
	case RECORD_CONTAINS:
		return "RECORD CONTAINS"
	case BLOCK_CONTAINS:
		return "BLOCK CONTAINS"
	case RECORDING_MODE:
		return "RECORDING MODE"
	case LABEL_RECORDS:
		return "LABEL RECORDS"
	case VALUE_OF:
		return "VALUE OF"
	case DATA_RECORDS:
		return "DATA RECORDS"
	case LINAGE_IS:
		return "LINAGE IS"
	case CODE_SET:
		return "CODE-SET"
	case REPORT_IS:
		return "REPORT IS"
	case REPORTS_ARE:
		return "REPORTS ARE"
	case CONTROL_IS:
		return "CONTROL IS"
	case CONTROLS_ARE:
		return "CONTROLS ARE"
	case PAGE_LIMIT:
		return "PAGE LIMIT"
	case HEADING_IS:
		return "HEADING IS"
	case FIRST_DETAIL:
		return "FIRST DETAIL"
	case LAST_DETAIL:
		return "LAST DETAIL"
	case FOOTING_IS:
		return "FOOTING IS"
	default:
		return "UNKNOWN"
	}
}

// IsLevelNumber checks if a string represents a valid COBOL level number
func IsLevelNumber(s string) bool {
	// Valid level numbers are 01-49, 66, 77, 88
	switch s {
	case "66", "77", "88":
		return true
	default:
		if len(s) == 2 {
			if s[0] == '0' || s[0] == '1' || s[0] == '2' || s[0] == '3' || s[0] == '4' {
				if s[1] >= '0' && s[1] <= '9' {
					return true
				}
			}
		}
		return false
	}
}

// Lookup determines if an identifier is a keyword
func Lookup(ident string) Token {
	if tok, isKeyword := keywords[ident]; isKeyword {
		return tok
	}
	if IsLevelNumber(ident) {
		return LEVEL_NUMBER
	}
	return IDENT
}
